/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/                                                                                                                                                                                                                                                                                                                                                                                                                        

/*--------------------------------------------------------------------------------------------*/

PARSER_BEGIN(Parser)

  package interprete;
  import interprete.ast.*;
  import interprete.visitor.*;


public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
}
PARSER_END(Parser)


/*---------------------------------------------------------------------------------------------*/

SKIP:
{
    " " /*Salta gli spazi*/
    | "\n"
    | "\t"
}

ASTProgramma Programma ():
{/*@bgen(jjtree) Programma */
  ASTProgramma jjtn000 = new ASTProgramma(JJTPROGRAMMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Programma */
    try {
/*@egen*/
    Comando() ";"( Comando() ";")* <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        {
            return jjtn000;
        }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Comando()      :
{
    Token sgn = null;
}
{        
                          
/*A seguito di ognuna di queste produzioni viene creato un oggetto della classe specificata dopo
il carattere #*/

      LOOKAHEAD(2)/*@bgen(jjtree) ComandoAssegnamento */
                   {
                     ASTComandoAssegnamento jjtn001 = new ASTComandoAssegnamento(JJTCOMANDOASSEGNAMENTO);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/ ( Variabile() "=" Funzione() )/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                     }
                   }
/*@egen*/
    | LOOKAHEAD(2)/*@bgen(jjtree) ComandoCalcolo */
                   {
                     ASTComandoCalcolo jjtn002 = new ASTComandoCalcolo(JJTCOMANDOCALCOLO);
                     boolean jjtc002 = true;
                     jjtree.openNodeScope(jjtn002);
                   }
                   try {
/*@egen*/ ( Variabile() "("[sgn = "-"] Num()

/*Se \u00e8 stato inserito il segno meno, si recupera il nodo di tipo Num creato e si inverte
il segno dell'argomento*/
                                                {
                                                    if(sgn != null)
                                                    {
                                                        ASTNum num = (ASTNum)jjtree.peekNode();
                                                        num.setValue(- num.getValue());
                                                    }
                                                } 
                                                ")?")/*@bgen(jjtree)*/
                   } catch (Throwable jjte002) {
                     if (jjtc002) {
                       jjtree.clearNodeScope(jjtn002);
                       jjtc002 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte002 instanceof RuntimeException) {
                       throw (RuntimeException)jjte002;
                     }
                     if (jjte002 instanceof ParseException) {
                       throw (ParseException)jjte002;
                     }
                     throw (Error)jjte002;
                   } finally {
                     if (jjtc002) {
                       jjtree.closeNodeScope(jjtn002, true);
                     }
                   }
/*@egen*/
    |/*@bgen(jjtree) ComandoStampa */
      {
        ASTComandoStampa jjtn003 = new ASTComandoStampa(JJTCOMANDOSTAMPA);
        boolean jjtc003 = true;
        jjtree.openNodeScope(jjtn003);
      }
      try {
/*@egen*/ ( Variabile() "?" )/*@bgen(jjtree)*/
      } catch (Throwable jjte003) {
        if (jjtc003) {
          jjtree.clearNodeScope(jjtn003);
          jjtc003 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte003 instanceof RuntimeException) {
          throw (RuntimeException)jjte003;
        }
        if (jjte003 instanceof ParseException) {
          throw (ParseException)jjte003;
        }
        throw (Error)jjte003;
      } finally {
        if (jjtc003) {
          jjtree.closeNodeScope(jjtn003, true);
        }
      }
/*@egen*/
    |/*@bgen(jjtree) ComandoAlbero */
      {
        ASTComandoAlbero jjtn004 = new ASTComandoAlbero(JJTCOMANDOALBERO);
        boolean jjtc004 = true;
        jjtree.openNodeScope(jjtn004);
      }
      try {
/*@egen*/ ( "tree" Variabile() )/*@bgen(jjtree)*/
      } catch (Throwable jjte004) {
        if (jjtc004) {
          jjtree.clearNodeScope(jjtn004);
          jjtc004 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte004 instanceof RuntimeException) {
          throw (RuntimeException)jjte004;
        }
        if (jjte004 instanceof ParseException) {
          throw (ParseException)jjte004;
        }
        throw (Error)jjte004;
      } finally {
        if (jjtc004) {
          jjtree.closeNodeScope(jjtn004, true);
        }
      }
/*@egen*/
    |/*@bgen(jjtree) ComandoElenco */
      {
        ASTComandoElenco jjtn005 = new ASTComandoElenco(JJTCOMANDOELENCO);
        boolean jjtc005 = true;
        jjtree.openNodeScope(jjtn005);
      }
      try {
/*@egen*/ "list"/*@bgen(jjtree)*/
      } finally {
        if (jjtc005) {
          jjtree.closeNodeScope(jjtn005, true);
        }
      }
/*@egen*/
    |/*@bgen(jjtree) ComandoCancellaVariabile */
      {
        ASTComandoCancellaVariabile jjtn006 = new ASTComandoCancellaVariabile(JJTCOMANDOCANCELLAVARIABILE);
        boolean jjtc006 = true;
        jjtree.openNodeScope(jjtn006);
      }
      try {
/*@egen*/ ("delete" Variabile())/*@bgen(jjtree)*/
      } catch (Throwable jjte006) {
        if (jjtc006) {
          jjtree.clearNodeScope(jjtn006);
          jjtc006 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte006 instanceof RuntimeException) {
          throw (RuntimeException)jjte006;
        }
        if (jjte006 instanceof ParseException) {
          throw (ParseException)jjte006;
        }
        throw (Error)jjte006;
      } finally {
        if (jjtc006) {
          jjtree.closeNodeScope(jjtn006, true);
        }
      }
/*@egen*/
    |/*@bgen(jjtree) ComandoCancellaTutto */
      {
        ASTComandoCancellaTutto jjtn007 = new ASTComandoCancellaTutto(JJTCOMANDOCANCELLATUTTO);
        boolean jjtc007 = true;
        jjtree.openNodeScope(jjtn007);
      }
      try {
/*@egen*/ "delete all"/*@bgen(jjtree)*/
      } finally {
        if (jjtc007) {
          jjtree.closeNodeScope(jjtn007, true);
        }
      }
/*@egen*/
    |/*@bgen(jjtree) ComandoDisegno */
      {
        ASTComandoDisegno jjtn008 = new ASTComandoDisegno(JJTCOMANDODISEGNO);
        boolean jjtc008 = true;
        jjtree.openNodeScope(jjtn008);
      }
      try {
/*@egen*/ ("draw" Variabile())/*@bgen(jjtree)*/
      } catch (Throwable jjte008) {
        if (jjtc008) {
          jjtree.clearNodeScope(jjtn008);
          jjtc008 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte008 instanceof RuntimeException) {
          throw (RuntimeException)jjte008;
        }
        if (jjte008 instanceof ParseException) {
          throw (ParseException)jjte008;
        }
        throw (Error)jjte008;
      } finally {
        if (jjtc008) {
          jjtree.closeNodeScope(jjtn008, true);
        }
      }
/*@egen*/
}


void Funzione()      :
{}
{
/*Costruisce un'istanza di Somma (o Differenza) aggiungendo come figli i primi due nodi estratti 
dallo stack. Quindi pone l'oggetto Somma sullo stack */
    Termine() ("+"/*@bgen(jjtree) #Somma( 2) */
                   {
                     ASTSomma jjtn001 = new ASTSomma(JJTSOMMA);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/ Termine()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
                   }
/*@egen*/ | "-"/*@bgen(jjtree) #Differenza( 2) */
                                             {
                                               ASTDifferenza jjtn002 = new ASTDifferenza(JJTDIFFERENZA);
                                               boolean jjtc002 = true;
                                               jjtree.openNodeScope(jjtn002);
                                             }
                                             try {
/*@egen*/ Termine()/*@bgen(jjtree)*/
                                             } catch (Throwable jjte002) {
                                               if (jjtc002) {
                                                 jjtree.clearNodeScope(jjtn002);
                                                 jjtc002 = false;
                                               } else {
                                                 jjtree.popNode();
                                               }
                                               if (jjte002 instanceof RuntimeException) {
                                                 throw (RuntimeException)jjte002;
                                               }
                                               if (jjte002 instanceof ParseException) {
                                                 throw (ParseException)jjte002;
                                               }
                                               throw (Error)jjte002;
                                             } finally {
                                               if (jjtc002) {
                                                 jjtree.closeNodeScope(jjtn002,  2);
                                               }
                                             }
/*@egen*/ )*           
}

void Termine()      :
{}
{
/*Coma sopra, ma con Prodotto (o Divisione)*/
    Monomio() ( "*"/*@bgen(jjtree) #Prodotto( 2) */
                    {
                      ASTProdotto jjtn001 = new ASTProdotto(JJTPRODOTTO);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*/ Monomio()/*@bgen(jjtree)*/
                    } catch (Throwable jjte001) {
                      if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte001 instanceof RuntimeException) {
                        throw (RuntimeException)jjte001;
                      }
                      if (jjte001 instanceof ParseException) {
                        throw (ParseException)jjte001;
                      }
                      throw (Error)jjte001;
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                      }
                    }
/*@egen*/ | "/"/*@bgen(jjtree) #Divisione( 2) */
                                                 {
                                                   ASTDivisione jjtn002 = new ASTDivisione(JJTDIVISIONE);
                                                   boolean jjtc002 = true;
                                                   jjtree.openNodeScope(jjtn002);
                                                 }
                                                 try {
/*@egen*/ Monomio()/*@bgen(jjtree)*/
                                                 } catch (Throwable jjte002) {
                                                   if (jjtc002) {
                                                     jjtree.clearNodeScope(jjtn002);
                                                     jjtc002 = false;
                                                   } else {
                                                     jjtree.popNode();
                                                   }
                                                   if (jjte002 instanceof RuntimeException) {
                                                     throw (RuntimeException)jjte002;
                                                   }
                                                   if (jjte002 instanceof ParseException) {
                                                     throw (ParseException)jjte002;
                                                   }
                                                   throw (Error)jjte002;
                                                 } finally {
                                                   if (jjtc002) {
                                                     jjtree.closeNodeScope(jjtn002,  2);
                                                   }
                                                 }
/*@egen*/ )*
}


    /*
     *  questa parte di grammatica (Monomio) viene modificata:
     *  il simbolo "^" deve essere trattato come un operatore binario, associativo a sinistra
     *  e con maggiore priorit\u00e0
    */
/*
void Monomio() #void:
{
    Node n, esp;
}
{*/
    /*Qui d\u00e0 un warning, cmq il parser funziona correttamente (stessa situazione del "dangling else")*/
    /*l'esponente viene automaticamente associato all'espansione pi\u00f9 interna*/
  /*
    MonomioSemplice() {n = jjtree.popNode();}
                      [Esponente() 
                        {
                         esp = jjtree.popNode();
                         ASTMonomio monomioConEsp = new ASTMonomio(ParserTreeConstants.JJTMONOMIO);
                         monomioConEsp.jjtAddChild(n,0);
                         monomioConEsp.jjtAddChild(esp,1);
                         n = monomioConEsp;
                        }
                      ] 
                      {jjtree.pushNode(n);} #Monomio(false)
}*/


/*
 *  segue la nuova grammatica 
 *  per la produzione di Monomio (Molto pi\u00f9 semplice, non \u00e8 vero?)
 *  Monomio -> MonomioSemplice ("^" MonomioSemplice)*
*/

void Monomio()        :
{}
{
    MonomioSemplice() ( "^"/*@bgen(jjtree) #Monomio( 2) */
                            {
                              ASTMonomio jjtn001 = new ASTMonomio(JJTMONOMIO);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*/ MonomioSemplice()/*@bgen(jjtree)*/
                            } catch (Throwable jjte001) {
                              if (jjtc001) {
                                jjtree.clearNodeScope(jjtn001);
                                jjtc001 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte001 instanceof RuntimeException) {
                                throw (RuntimeException)jjte001;
                              }
                              if (jjte001 instanceof ParseException) {
                                throw (ParseException)jjte001;
                              }
                              throw (Error)jjte001;
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                              }
                            }
/*@egen*/ )*
}    

void MonomioSemplice()     :
{
    Node var;
    Node arg = null;
}
{
      Num()
/*Funzione precedentemente inserita*/
    | Variabile() 
        {var = jjtree.popNode();}   
                "(" Funzione() ")"
                    {
                        arg = jjtree.popNode();
                    }
         {
            if (arg != null)
            var.jjtAddChild(arg,0);
            jjtree.pushNode(var);
         }
    | VariabileIndipendente()   /* --> "x" */
    | Seno()
    | Coseno()
    | Tangente()
    | Cotangente()
    | ArcoSeno()
    | ArcoCoseno()
    | ArcoTangente()
    | ArcoCotangente()
    | MonomioNegativo()
    | LogaritmoNaturale()
    | Logaritmo()
    | ValoreAssoluto()
    | Esponenziale()
    | Fattoriale()
    | Radice()
    | "(" Funzione() ")"
}

void Num():
{/*@bgen(jjtree) Num */
    ASTNum jjtn000 = new ASTNum(JJTNUM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token parteInt = null;
    Token parteFraz = null;
    double value;
}
{/*@bgen(jjtree) Num */
    try {
/*@egen*/
    parteInt = <INTERO> [parteFraz = <PARTEFRAZ>]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        {
            if (parteFraz == null)
                value = Double.parseDouble(parteInt.image);
            else
                value = Double.parseDouble(parteInt.image+parteFraz.image);
            jjtn000.setValue(value);
        }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Seno():
{/*@bgen(jjtree) Seno */
  ASTSeno jjtn000 = new ASTSeno(JJTSENO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Seno */
    try {
/*@egen*/
    ("sin" | "sen") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Coseno():
{/*@bgen(jjtree) Coseno */
  ASTCoseno jjtn000 = new ASTCoseno(JJTCOSENO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Coseno */
    try {
/*@egen*/
    "cos" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Tangente():
{/*@bgen(jjtree) Tangente */
  ASTTangente jjtn000 = new ASTTangente(JJTTANGENTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Tangente */
    try {
/*@egen*/
    ("tan" | "tg") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Cotangente():
{/*@bgen(jjtree) Cotangente */
  ASTCotangente jjtn000 = new ASTCotangente(JJTCOTANGENTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Cotangente */
    try {
/*@egen*/
    ("cotan" | "cotg") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArcoSeno():
{/*@bgen(jjtree) ArcoSeno */
  ASTArcoSeno jjtn000 = new ASTArcoSeno(JJTARCOSENO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArcoSeno */
    try {
/*@egen*/
    ("arcsin" | "arcsen") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArcoCoseno():
{/*@bgen(jjtree) ArcoCoseno */
  ASTArcoCoseno jjtn000 = new ASTArcoCoseno(JJTARCOCOSENO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArcoCoseno */
    try {
/*@egen*/
    "arccos" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArcoTangente():
{/*@bgen(jjtree) ArcoTangente */
  ASTArcoTangente jjtn000 = new ASTArcoTangente(JJTARCOTANGENTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArcoTangente */
    try {
/*@egen*/
    ("arctan" | "arctg") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArcoCotangente():
{/*@bgen(jjtree) ArcoCotangente */
  ASTArcoCotangente jjtn000 = new ASTArcoCotangente(JJTARCOCOTANGENTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArcoCotangente */
    try {
/*@egen*/
    ("arccotan" | "arccotg") Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MonomioNegativo():
{/*@bgen(jjtree) MonomioNegativo */
  ASTMonomioNegativo jjtn000 = new ASTMonomioNegativo(JJTMONOMIONEGATIVO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MonomioNegativo */
    try {
/*@egen*/
    "-" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LogaritmoNaturale():
{/*@bgen(jjtree) LogaritmoNaturale */
  ASTLogaritmoNaturale jjtn000 = new ASTLogaritmoNaturale(JJTLOGARITMONATURALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogaritmoNaturale */
    try {
/*@egen*/
    "ln" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*Pendente: \u00e8 meglio mettere i figli di Logaritmo nell'ordine: 1-base, 2-argomento o il contrario?
  Attualmente si adotta la prima*/

void Logaritmo()      :
{
    Node n, log, arg; /*Variabile appoggio*/
    ASTNum num = null;
}
{
    "log"["<"Num()">"
            {
                n = jjtree.popNode();   /*rimuovo l'eventuale Num dallo stack*/
                num = (ASTNum) n;       /*cast sicuro: n \u00e8 sicuramente un ASTNum*/
            }
         ] Monomio()/*@bgen(jjtree) #Logaritmo( false) */
            {
              ASTLogaritmo jjtn001 = new ASTLogaritmo(JJTLOGARITMO);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*//*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn001,  false);
              jjtc001 = false;
            }
/*@egen*/
            {
                arg = jjtree.popNode(); /*rimuovo il dallo stack il sotto-albero creato dalla chiamata a Monomio()*/
                if(num == null)         /*non \u00e8 stata specificata la base del logaritmo => base = 10*/
                    {
                        num = new ASTNum(ParserTreeConstants.JJTNUM);
                        num.setValue(10);
                    }
            /*Aggiungo i figli nell'ordine corretto*/
            log = new ASTLogaritmo(ParserTreeConstants.JJTLOGARITMO);
            log.jjtAddChild(num,0);
            log.jjtAddChild(arg,1);
            jjtree.pushNode(log);
            }/*@bgen(jjtree)*/
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  false);
              }
            }
/*@egen*/
}

void ValoreAssoluto():
{/*@bgen(jjtree) ValoreAssoluto */
  ASTValoreAssoluto jjtn000 = new ASTValoreAssoluto(JJTVALOREASSOLUTO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ValoreAssoluto */
    try {
/*@egen*/
    "abs" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Esponenziale():
{/*@bgen(jjtree) Esponenziale */
  ASTEsponenziale jjtn000 = new ASTEsponenziale(JJTESPONENZIALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Esponenziale */
    try {
/*@egen*/
    "exp" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Fattoriale():
{/*@bgen(jjtree) Fattoriale */
  ASTFattoriale jjtn000 = new ASTFattoriale(JJTFATTORIALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Fattoriale */
    try {
/*@egen*/
    "fact" Monomio()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*Una radice \u00e8 matematicamente identica ad un esponente frazionario --> 
  si sceglie una rappresentazione omagenea tramite la classe ASTMonomio
  Occorre creare "a mano" il seguente sotto-albero Monomio, corrispondente ad un radice:

  \indice/arg --> arg^(1/indice)

  Monomio               --> radiceFormaEsponenziale
    Argomento           --> arg
        <sotto-albero>  
    Esponente           --> esp
        Num             --> indice
*/

void Radice()      :
{
    Node arg;
    Node i = null;
    ASTNum indice = null;
}
{
    "\\" [Num()
            {
                i = jjtree.popNode();
                indice = (ASTNum)i;
                indice.setValue(1/indice.getValue());      /* Esponente = 1/indice */
            }
         ] "/" Monomio() 
                    {
                        if(indice == null) /*non \u00e8 stato esplicitato l'indice => radice quadrata, indice=2*/
                        {
                            indice = new ASTNum(ParserTreeConstants.JJTNUM);
                            indice.setValue(0.5);
                        }
                        arg = jjtree.popNode();
                        ASTMonomio radiceFormaEsponenziale = new ASTMonomio(ParserTreeConstants.JJTMONOMIO);
                        radiceFormaEsponenziale.jjtAddChild(arg,0);
                        radiceFormaEsponenziale.jjtAddChild(indice,1);
                        jjtree.pushNode(radiceFormaEsponenziale);
                    }
}

void Variabile():
{/*@bgen(jjtree) Variabile */
    ASTVariabile jjtn000 = new ASTVariabile(JJTVARIABILE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) Variabile */
    try {
/*@egen*/
    t = <VARLITERAL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
        {
            jjtn000.setName(t.image);
        }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VariabileIndipendente():
{/*@bgen(jjtree) VariabileIndipendente */
  ASTVariabileIndipendente jjtn000 = new ASTVariabileIndipendente(JJTVARIABILEINDIPENDENTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariabileIndipendente */
    try {
/*@egen*/
    <VARINDIPLITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
    

TOKEN:
{
    /*Pendente: come fare per distinguere fra i token INTERO e PARTEFRAZ??*/
    <INTERO: "0" | ["1" - "9"] (["0" - "9"])* >
    | <PARTEFRAZ: "." (["0" - "9"])+>
    | <VARLITERAL: (["a"-"v","y"-"z"] | ["A"-"V","Y"-"Z"]) (["0"-"9"] | ["a"-"z"] | ["A"-"Z"])*>
    | <VARINDIPLITERAL: "x">
}